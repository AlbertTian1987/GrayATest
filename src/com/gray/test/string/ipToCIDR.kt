package com.gray.test.string

/***
 * 751. IP 到 CIDR
 * 给定一个起始 IP 地址 ip 和一个我们需要包含的 IP 的数量 n，返回用列表（最小可能的长度）表示的 CIDR块的范围。
 * CIDR 块是包含 IP 的字符串，后接斜杠和固定长度。例如：“123.45.67.89/20”。固定长度 “20” 表示在特定的范围中公共前缀位的长度。
 *
 * 示例 1：
 * 输入：ip = "255.0.0.7", n = 10
 * 输出：["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
 * 解释：
 * 转换为二进制时，初始IP地址如下所示（为清晰起见添加了空格）：
 * 255.0.0.7 -> 11111111 00000000 00000000 00000111
 * 地址 "255.0.0.7/32" 表示与给定地址有相同的 32 位前缀的所有地址，
 * 在这里只有这一个地址。
 *
 * 地址 "255.0.0.8/29" 表示与给定地址有相同的 29 位前缀的所有地址：
 * 255.0.0.8 -> 11111111 00000000 00000000 00001000
 * 有相同的 29 位前缀的地址如下：
 * 11111111 00000000 00000000 00001000
 * 11111111 00000000 00000000 00001001
 * 11111111 00000000 00000000 00001010
 * 11111111 00000000 00000000 00001011
 * 11111111 00000000 00000000 00001100
 * 11111111 00000000 00000000 00001101
 * 11111111 00000000 00000000 00001110
 * 11111111 00000000 00000000 00001111
 *
 * 地址 "255.0.0.16/32" 表示与给定地址有相同的 32 位前缀的所有地址，
 * 这里只有 11111111 00000000 00000000 00010000。
 * 总之，答案指定了从 255.0.0.7 开始的 10 个 IP 的范围。
 * 有一些其他的表示方法，例如：
 * ["255.0.0.7/32","255.0.0.8/30", "255.0.0.12/30", "255.0.0.16/32"],
 * 但是我们的答案是最短可能的答案。
 * 另外请注意以 "255.0.0.7/30" 开始的表示不正确，
 * 因为其包括了 255.0.0.4 = 11111111 00000000 00000000 00000100 这样的地址，
 * 超出了需要表示的范围。
 *
 * 注：
 * ip 是有效的 IPv4 地址。
 * 每一个隐含地址 ip + x (其中 x < n) 都是有效的 IPv4 地址。
 * n 为整数，范围为 [1, 1000]。
 */
//https://zhuanlan.zhihu.com/p/35541808

fun ipToCIDR(ip: String, n: Int): List<String> {
    //思路，找到这些IPs中从右往左第一位相同的二进制位
    // x & -x ;-x是x的补码，返回x与2^64的最大公约数，
    //即x最多能被n个2整除就返回2^n,如果x是奇数返回1;返回值为0 ，说明x=0;为其他数，表示x为x与2^64的最大公约数
    //一言以蔽之就是获取32位二进制表示中从右往左首次出现1的位置

    val ret = arrayListOf<String>()
    var x = 0L
    //以"."划分每个IP
    val ips = ip.split('.')
    for (s in ips) {
        x = x * 256 + s.toInt()
    }
    var p = n
    while (p > 0) {
        var temp = x.and(x.inv() + 1)//求得该IP用32位二进制表示中从右往左首次出现1的位置
        //-x才是x的补码，~x为反码
        //temp如果为奇数，则该IP为第一个CIDR块
        //如果偶数，则该IP用二进制表示下的最低有效位的位数能表示的地址的数量
        while (temp > p) {
            temp /= 2
        }
        //到这里temp肯定是小于n的，这告诉我们包括此IP在内的temp个IPs可以用一个ICDR来表示
        //接下来求出这些IPs所处的CIDR
        ret.add(longToIP(x, temp.toInt()))
        //x加上temp;
        x += temp//temp个ips考虑好了，接下来考虑从x+temp考虑
        p -= temp.toInt()//还有几个IPs要求ICDR的
    }

    return ret
}

fun longToIP(p: Long, s: Int): String {
    var x = p
    var step = s
    val ans = IntArray(4)
    //&255操作求出后8位十进制表示
    ans[0] = x.and(255).toInt()
    //右移8位，即求下一个块
    x = x shr 8
    ans[1] = x.and(255).toInt()
    x = x shr 8
    ans[2] = x.and(255).toInt()
    x = x shr 8
    ans[3] = x.toInt()
    var len = 33
    //每一位就可以表示2个
    while (step > 0) {
        len--
        step /= 2
    }
    return "${ans[3]}.${ans[2]}.${ans[1]}.${ans[0]}/$len"
}

fun main() {
    println(ipToCIDR("255.255.255.7", 10))
}