package com.gray.test.dynamicPlan

import kotlin.math.min

/***
 * 256. 粉刷房子
 * 假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，
 * 你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。
 * 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。
 * 每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。
 * 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；
 * costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。
 *
 * 注意：
 * 所有花费均为正整数。
 *
 * 示例：
 * 输入: [[17,2,17],[16,16,5],[14,3,19]]
 * 输出: 10
 * 解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
 * 最少花费: 2 + 5 + 3 = 10。
 *
 * */

/**
 * 转换方程如下: dp[i ][ j] 表示粉刷到第i栋房子时，使用j颜色，需要的最小花费
 * dp[i][j ] = costs[i][j ] + min(dp[i-1][(j + 1) % 3], dp[i-1][(j + 2) % 3])
 * 解释： 比如粉刷第二栋房子， 它粉刷蓝色的最小花费等于 它蓝色的钱+（之前一栋房子选择我红色，或绿色里较小的）
 * 所以下文代码里，将costs用作dp来记录过往的值，节约空间
 *
 */
fun minCost(costs: Array<IntArray>): Int {
    if (costs.isEmpty()) {
        return 0
    }
    for (i in 1 until costs.size) {
        for (j in 0 until 3) {
            costs[i][j] += min(costs[i - 1][(j + 1) % 3], costs[i - 1][(j + 2) % 3])
        }
    }
    val last = costs.last()
    return min(last[0], min(last[1], last[2]))
}